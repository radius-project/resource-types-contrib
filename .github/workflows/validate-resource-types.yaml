name: Validate Resource Types

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Radius version number to use (e.g. 0.1.0, 0.1.0-rc1, edge). Defaults to edge.'
        required: false
        default: 'edge'
        type: string

jobs:
  validate-resource-types:
    runs-on: ubuntu-latest
    name: Validate Resource Type Schemas
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 16
      - name: Download k3d
        run: wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash
      - name: Create k3d cluster
        # Map localhost port 80 on the external load balancer, and disable traefik and the internal load balancer.
        run: k3d cluster create --agents 2 -p "80:80@loadbalancer" --k3s-arg "--disable=traefik@server:*" --k3s-arg "--disable=servicelb@server:*" --registry-create reciperegistry:51351
      - name: Set up ORAS
        uses: oras-project/setup-oras@v1
        with:
          version: '1.2.0'
      - name: Verify ORAS installation
        run: oras version
      - name: Download rad CLI
        # TODO: remove URL and use environment variable
        run: |
          echo "Downloading latest rad CLI"
          wget -q "https://raw.githubusercontent.com/radius-project/radius/main/deploy/install.sh" -O - | /bin/bash -s edge
      - name: Initialize default environment
        run: |
          rad install kubernetes --set rp.publicEndpointOverride=localhost
          rad group create default
          rad workspace create kubernetes default --group default
          rad group switch default
          rad env create default
          rad env switch default
      - name: Verify manifests are registered
        if: env.SKIP_BUILD != 'true'
        run: |
          rm -f registermanifest_logs.txt
          # Find the pod with container "ucp"
          POD_NAME=$(
            kubectl get pods -n radius-system \
              -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.spec.containers[*].name}{"\n"}{end}' \
            | grep "ucp" \
            | head -n1 \
            | cut -d" " -f1
          )
          echo "Found ucp pod: $POD_NAME"

          if [ -z "$POD_NAME" ]; then
            echo "No pod with container 'ucp' found in namespace radius-system."
            exit 1
          fi

          # Poll logs for up to 20 iterations, 30 seconds each (up to 10 minutes total)
          for i in {1..20}; do
            kubectl logs "$POD_NAME" -n radius-system | tee registermanifest_logs.txt > /dev/null

            # Exit on error
            if grep -qi "Service initializer terminated with error" registermanifest_logs.txt; then
              echo "Error found in ucp logs."
              grep -i "Service initializer terminated with error" registermanifest_logs.txt
              exit 1
            fi

            # Check for success
            if grep -q "Successfully registered manifests" registermanifest_logs.txt; then
              echo "Successfully registered manifests - message found."
              break
            fi

            echo "Logs not ready, waiting 30 seconds..."
            sleep 30
          done

          # Final check to ensure success message was found
          if ! grep -q "Successfully registered manifests" registermanifest_logs.txt; then
            echo "Manifests not registered after 10 minutes."
            exit 1
          fi

      - name: Create resource types from resource folders
        run: |
          # Define common configuration
          setup_config() {
            resource_folders=("Compute" "Security")
            declare -g -A folder_to_namespace=(
              ["Compute"]="Radius.Compute"
              ["Security"]="Radius.Security"
            )
          }

          setup_config
          echo "Finding YAML files in resource type folders (safe handling of filenames)..."

          # Collect YAML files into a bash array safely (handles spaces/newlines)
          all_yaml_files=()
          for folder in "${resource_folders[@]}"; do
            if [[ -d "./$folder" ]]; then
              echo "Searching in folder: $folder"
              while IFS= read -r -d '' file; do
                all_yaml_files+=("$file")
              done < <(find "./$folder" -name "*.yaml" -type f -print0)
            else
              echo "Folder $folder does not exist, skipping..."
            fi
          done

          if [[ ${#all_yaml_files[@]} -eq 0 ]]; then
            echo "No YAML files found in any resource type folders"
            exit 0
          fi

          echo "Creating resource types..."
          for yaml_file in "${all_yaml_files[@]}"; do
            echo "Processing: $yaml_file"

            # Extract resource type name from the file path
            resource_name=$(basename "$yaml_file" .yaml)

            echo "Creating resource type '$resource_name' from $yaml_file..."
            if rad resource-type create "$resource_name" -f "$yaml_file"; then
              echo "✅ Successfully created resource type: $resource_name"
            else
              echo "❌ Failed to create resource type: $resource_name"
              exit 1
            fi
          done

          echo "✅ All resource types created successfully"

      - name: Verify expected resource types are present
        run: |
          # Define common configuration
          setup_config() {
            resource_folders=("Compute" "Security")
            declare -g -A folder_to_namespace=(
              ["Compute"]="Radius.Compute"
              ["Security"]="Radius.Security"
            )
          }
          
          setup_config
          echo "Listing all resource types..."
          rad resource-type list
          
          echo "Verifying expected resource types..."
          
          # Build expected resource types list dynamically
          expected_resource_types=()
          for folder in "${resource_folders[@]}"; do
            if [[ -d "./$folder" ]]; then
              folder_yaml_files=$(find "./$folder" -name "*.yaml" -type f)
              radius_namespace="${folder_to_namespace[$folder]}"
              for yaml_file in $folder_yaml_files; do
                resource_name=$(basename "$yaml_file" .yaml)
                expected_resource_types+=("$radius_namespace/$resource_name")
              done
            fi
          done
          
          if [[ ${#expected_resource_types[@]} -eq 0 ]]; then
            echo "No expected resource types found"
            exit 0
          fi
          
          echo "Expected resource types:"
          printf '%s\n' "${expected_resource_types[@]}"
          
          # Get the list of resource types
          resource_type_list=$(rad resource-type list)
          
          verification_failed=false
          
          for expected_type in "${expected_resource_types[@]}"; do
            echo "Checking for resource type: $expected_type"
            
            if echo "$resource_type_list" | grep -q "$expected_type"; then
              echo "✅ Found resource type: $expected_type"
            else
              echo "❌ Missing resource type: $expected_type"
              verification_failed=true
            fi
          done
          
          if [[ "$verification_failed" == "true" ]]; then
            echo "❌ Resource type verification failed"
            echo "Expected resource types not found in the list"
            exit 1
          else
            echo "✅ All expected resource types are present"
          fi

      - name: Publish Bicep extensions
        run: |
          # Define common configuration
          setup_config() {
            resource_folders=("Compute" "Security")
            declare -g -A folder_to_namespace=(
              ["Compute"]="Radius.Compute"
              ["Security"]="Radius.Security"
            )
          }

          setup_config
          echo "Publishing Bicep extensions for all YAML files (safe handling of filenames)..."

          all_yaml_files=()
          for folder in "${resource_folders[@]}"; do
            if [[ -d "./$folder" ]]; then
              while IFS= read -r -d '' file; do
                all_yaml_files+=("$file")
              done < <(find "./$folder" -name "*.yaml" -type f -print0)
            fi
          done

          if [[ ${#all_yaml_files[@]} -eq 0 ]]; then
            echo "No YAML files found in resource type folders"
            exit 0
          fi

          for yaml_file in "${all_yaml_files[@]}"; do
            echo "Publishing extension for $yaml_file..."

            resource_name=$(basename "$yaml_file" .yaml)
            extension_name="${resource_name}-extension"

            echo "Publishing extension '$extension_name.tgz' from $yaml_file..."
            if rad bicep publish-extension -f "$yaml_file" --target "$extension_name.tgz"; then
              echo "✅ Successfully published extension: $extension_name.tgz"
            else
              echo "❌ Failed to publish extension: $extension_name.tgz"
              exit 1
            fi
          done

          echo "✅ All Bicep extensions published successfully"

      - name: Update bicepconfig.json with published extensions
        run: |
          echo "Updating bicepconfig.json with published extensions..."
          
          # Find all published .tgz files and add them to bicepconfig.json (safe handling)
          tgz_files=()
          while IFS= read -r -d '' f; do
            tgz_files+=("$f")
          done < <(find . -name "*-extension.tgz" -type f -print0)

          if [[ ${#tgz_files[@]} -gt 0 ]]; then
            echo "Found extension files to add to bicepconfig.json:"
            printf '%s\n' "${tgz_files[@]}"

            for tgz_file in "${tgz_files[@]}"; do
              # Extract resource name from filename (e.g., "./containers-extension.tgz" -> "containers")
              filename=$(basename "$tgz_file")
              resource_name=${filename%-extension.tgz}

              echo "Adding extension '$resource_name' with file '$tgz_file' to bicepconfig.json..."

              # Update bicepconfig.json using jq
              jq --arg name "$resource_name" --arg path "$tgz_file" \
                '.extensions[$name] = $path' bicepconfig.json > bicepconfig.tmp && \
                mv bicepconfig.tmp bicepconfig.json
            done

            echo "✅ Successfully updated bicepconfig.json with extensions"
          else
            echo "No extension .tgz files found to add to bicepconfig.json"
          fi

          echo "Final bicepconfig.json content:"
          cat bicepconfig.json

      - name: Register Kubernetes recipes
        run: |
          # Define common configuration
          setup_config() {
            resource_folders=("Compute" "Security")
            declare -g -A folder_to_namespace=(
              ["Compute"]="Radius.Compute"
              ["Security"]="Radius.Security"
            )
          }
          
          # Function to find recipe files by pattern across resource folders
          find_recipe_files() {
            local path_pattern="$1"
            local found_files=""
            for folder in "${resource_folders[@]}"; do
              if [[ -d "./$folder" ]]; then
                echo "Searching for recipes in $folder folder..."
                local folder_files=$(find "./$folder" -path "$path_pattern" -type f)
                if [[ -n "$folder_files" ]]; then
                  found_files="$found_files $folder_files"
                  echo "Found recipe files in $folder:"
                  echo "$folder_files"
                else
                  echo "No recipe files found in $folder folder"
                fi
              fi
            done
            echo "$found_files"
          }
          
          # Function to extract path components
          extract_path_info() {
            local file_path="$1"
            local root_folder=$(echo "$file_path" | sed 's|^./||' | cut -d'/' -f1)
            local resource_type=$(echo "$file_path" | sed 's|^./||' | cut -d'/' -f2)
            local platform_service=$(echo "$file_path" | sed 's|^./||' | cut -d'/' -f4)  # e.g., kubernetes-basic
            local file_name=$(basename "$file_path")
            echo "$root_folder $resource_type $platform_service $file_name"
          }
          
          setup_config
          echo "Waiting for registry to be ready..."
          
          # Wait for the registry to respond
          for i in {1..15}; do
            if curl -fsS http://localhost:51351/v2/_catalog >/dev/null 2>&1; then
              echo "✅ Registry is ready"
              break
            fi
            echo "Waiting for registry to be ready... ($i/15)"
            sleep 2
          done
          
          # Final check
          if ! curl -fsS http://localhost:51351/v2/_catalog >/dev/null 2>&1; then
            echo "❌ Registry is not ready after 30 seconds"
            exit 1
          fi
          
          echo "Finding and registering Kubernetes Bicep recipes..."
          
          # Find recipe files safely into an array
          k8s_recipes=()
          while IFS= read -r -d '' f; do
            k8s_recipes+=("$f")
          done < <(find . -path "*/recipes/kubernetes-*/*.bicep" -type f -print0)

          if [[ ${#k8s_recipes[@]} -eq 0 ]]; then
            echo "No Kubernetes recipe files found"
            exit 0
          fi

          # Group recipes by platform service for separate processing
          declare -A platform_recipes
          for recipe_file in "${k8s_recipes[@]}"; do
            # Extract path components robustly
            # Expecting: ./<root_folder>/<resource_type>/recipes/<platform_service>/<file>
            relpath="${recipe_file#./}"
            IFS='/' read -r root_folder resource_type _recipes_dir platform_service file_name <<< "$relpath"

            if [[ -z "$root_folder" || -z "$resource_type" || -z "$platform_service" ]]; then
              echo "❌ Unexpected recipe path structure: $recipe_file"
              exit 1
            fi

            # Group by platform service (e.g., kubernetes-container, kubernetes-secret)
            platform_key="$root_folder/$resource_type/$platform_service"
            if [[ -z "${platform_recipes[$platform_key]}" ]]; then
              platform_recipes[$platform_key]="$recipe_file"
            else
              platform_recipes[$platform_key]="${platform_recipes[$platform_key]} $recipe_file"
            fi
          done

          # Process each platform service group separately with immediate testing
          for platform_key in "${!platform_recipes[@]}"; do
            IFS='/' read -r root_folder resource_type platform_service <<< "$platform_key"
            echo ""
            echo "🔄 Processing platform service: $platform_service for $root_folder/$resource_type"
            
            # Get the Radius namespace for this folder
            radius_namespace="${folder_to_namespace[$root_folder]}"
            if [[ -z "$radius_namespace" ]]; then
              echo "❌ Unknown root folder: $root_folder"
              exit 1
            fi

            # Process all recipes for this platform service
            for recipe_file in ${platform_recipes[$platform_key]}; do
              recipe_name=$(basename "$recipe_file" .bicep)
              
              # Use platform_service as part of the registry path for uniqueness
              registry_path="localhost:51351/recipes/$resource_type/$platform_service/$recipe_name:latest"

              echo "Publishing recipe '$recipe_name' from '$platform_service' to registry: $registry_path"
              if rad bicep publish --file "$recipe_file" --target "br:$registry_path" --plain-http; then
                echo "✅ Successfully published recipe to registry: $registry_path"
              else
                echo "❌ Failed to publish recipe to registry: $recipe_name"
                exit 1
              fi

              echo "Registering recipe 'default' for resource type '$radius_namespace/$resource_type'"
              internal_registry_path="reciperegistry:5000/recipes/$resource_type/$platform_service/$recipe_name:latest"
              if rad recipe register default --environment default --resource-type "$radius_namespace/$resource_type" --template-kind bicep --template-path "$internal_registry_path" --plain-http; then
                echo "✅ Successfully registered recipe: default for $platform_service"
              else
                echo "❌ Failed to register recipe: default for $platform_service"
                exit 1
              fi
            done
            
            # Deploy test application for this resource type immediately after registration
            test_app_path="$root_folder/$resource_type/app.bicep"
            
            if [[ -f "$test_app_path" ]]; then
              echo ""
              echo "🚀 Deploying test application for $platform_service..."
              
              deployment_name="test-${root_folder,,}-${platform_service}-$(date +%s)"
              
              echo "Deploying $test_app_path as application: $deployment_name"
              if rad deploy "$test_app_path" --application "$deployment_name"; then
                echo "✅ Successfully deployed test application for $platform_service"
                
                # Clean up the deployment immediately
                echo "Cleaning up deployment: $deployment_name"
                rad app delete "$deployment_name" --yes || echo "⚠️ Failed to clean up deployment: $deployment_name"
                echo "✅ Cleaned up test deployment for $platform_service"
              else
                echo "❌ Failed to deploy test application for $platform_service"
                exit 1
              fi
            else
              echo "ℹ️ No test application found for $platform_service at $test_app_path, skipping deployment test..."
            fi
            
            echo "✅ Completed processing platform service: $platform_service"
          done

          echo "✅ All Kubernetes recipes published, registered, and tested successfully"

          echo "Listing all registered recipes..."
          rad recipe list --environment default
